---
description: Custom nodes in Svelte Flow are just Svelte components. This guide shows you how to implement your own nodes complete with target/source handles.
---

import { RemoteCodeViewer } from 'xy-shared/server';
import { Callout } from 'nextra/components';

# Custom Nodes

A powerful feature of Svelte Flow is the ability to create custom nodes. This gives you the flexibility to render anything you want within your nodes. We generally recommend creating your own custom nodes rather than relying on built-in ones. With custom nodes, you can add as many source and target handles as you like—or even embed form inputs, charts, and other interactive elements.

In this section, we'll walk through creating a custom node featuring an input field that updates text elsewhere in your application. For further examples, we recommend checking out our [Custom Node Example](/examples/nodes/custom-node).

## Implementing a Custom Node

To create a custom node, all you need to do is create a Svelte component. Svelte Flow will automatically wrap it in an interactive container that injects essential props like the node's id, position, and data, and provides functionality for selection, dragging, and connecting handles. For a full reference on all available custom node props, take a look at the [Node Props](/api-reference/types/node-props).

Let's dive into an example by creating a custom node called `TextUpdaterNode`. For this, we've added a controlled input field with a oninput handler. We simply use the 'text' property from the node's data for the input and we update the nodes data via the [`updateNodeData`](/api-reference/hooks/use-svelte-flow#update-node-data) function, that can be accessed through the [`useSvelteFlow`](/api-reference/hooks/use-svelte-flow) hook.

Svelte Flow has a few handy [pre-built components](/api-reference/components) to simplify the process of creating custom nodes. We will use the [`Handle`](/api-reference/components/handle) component to allow our custom node to connect with other nodes.

```svelte
<script lang="ts">
  import { Position, useSvelteFlow, type NodeProps } from '@xyflow/svelte';

  let { id, data }: NodeProps = $props();

  let { updateNodeData } = useSvelteFlow();
</script>

<div class="text-updater-node">
  <div>
    <label for="text">Text:</label>
    <input
      id="text"
      name="text"
      value={data.text}
      oninput={(evt) => {
        updateNodeData(id, { text: evt.target.value });
      }}
      class="nodrag"
    />
  </div>
</div>
```

## Adding the Node Type

Now we need to communicate the new custom node to Svelte Flow. You can add custom nodes by passing the [`nodeTypes`](/api-reference/svelte-flow#node-types) prop.

```svelte
<script>
  import { SvelteFlow } from '@xyflow/svelte';
  import TextUpdaterNode from './TextUpdaterNode.svelte';

  const nodeTypes = { textUpdater: TextUpdaterNode };

  // [...]

</script>

<SvelteFlow
  bind:nodes
  bind:edges
  {nodeTypes}
  fitView
>
  <!-- [...] -->
</SvelteFlow>
```

After defining your new node type, you can refer to it by using the `type` node option:

```js
const nodes = $state.raw([
  {
    id: 'node-1',
    type: 'textUpdater',
    position: { x: 0, y: 0 },
    data: { text: 'some text' },
  },
]);
```

After putting all together and adding some basic styles we get a custom node that prints text to the console:

<RemoteCodeViewer route="guides/custom-nodes" framework="svelte" />

## Utility Classes

Svelte Flow provides several built-in utility CSS classes to help you fine-tune how interactions work within your custom nodes.

### `nodrag`

In the example above, we added the class `nodrag` to the input. This ensures that interacting with the input field doesn't trigger a drag, allowing you to select the text within the field.

Nodes have a `drag` class name in place by default. However, this class name can affect the behaviour of the event listeners inside your custom nodes. To prevent unexpected behaviours, add a `nodrag` class name to elements with an event listener. This prevents the default drag behavior as well as the default node selection behavior when elements with this class are clicked.

```svelte filename="CustomNode.svelte" highlight="nodrag"
<div>
  <input class="nodrag" type="range" min={0} max={100} />
</div>
```

### `nowheel`

If your custom node contains scrollable content, you can apply the `nowheel` class. This disables the canvas' default pan behavior when you scroll inside your custom node, ensuring that only the content scrolls instead of moving the entire canvas.

```svelte filename="CustomNode.svelte" highlight="nowheel"
<div class="nowheel" style="overflow: auto">
  <p>Scrollable content...</p>
</div>
```

Applying these utility classes helps you control interaction on a granular level. You can customize these class names through Svelte Flow [style props](/api-reference/svelte-flow/#style-props).

<Callout type="info">
  When creating your own custom nodes, you will also need to remember to style them!
  Unlike the built-in nodes, custom nodes have no default styles, so feel free to use any
  styling method you prefer, such as Svelte's scoped CSS.
</Callout>

## Adding Handles

When defining edge connections to other nodes using these handles, simply using the node `id` isn't enough. You will also need to specify a handle `id`. In this case, we assign an id `a` to one source handle and an id `b` to the other source handle.

In Svelte Flow, edges can be connected to specific handles within a node using the properties `sourceHandle` (for the edge's starting point) and `targetHandle` (for the edge's ending point). When you have multiple handles on a node—for example, two source handles labeled "`a`" and "`b`", simply specifying the node's `id` isn't enough for Svelte Flow to know which connection point to use. By defining `sourceHandle` or `targetHandle` with the appropriate handle `id`, you instruct Svelte Flow to attach the edge to that specific handle, ensuring that connections are made where you intend.

```js
const initialEdges = [
  { id: 'edge-1', source: 'node-1', sourceHandle: 'a', target: 'node-2' },
  { id: 'edge-2', source: 'node-1', sourceHandle: 'b', target: 'node-3' },
];
```

In this case, the source node is `node-1` for both handles but the handle `id`s are different. One comes from handle id `"a"` and the other one from `"b"`. Both edges also have different target nodes:

<RemoteCodeViewer route="guides/custom-nodes-multiple-handles" framework="svelte" />

If you are programmatically changing the position or number of handles
in your custom node, you will need to use the
[`useUpdateNodeInternals`](/api-reference/hooks/use-update-node-internals) context function
to properly notify Svelte Flow of changes.
